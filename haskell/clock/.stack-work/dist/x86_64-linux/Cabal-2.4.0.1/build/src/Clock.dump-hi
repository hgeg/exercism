
==================== FINAL INTERFACE ====================
2019-02-22 19:00:38.99474654 UTC

interface exercism-clock-2.3.0.8-KPE91lmxtbmH6ajC9xI2mZ:Clock 8063
  interface hash: 5c73c79193f80b940f65e4be38d3fcbf
  ABI hash: 6e1bd40d866ad2c02cfc9c2a7e7fd0df
  export-list hash: a78c54f1835b998da94c7003729b32a0
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: d59a86fc39dabe8754ebbfb830e37f1e
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Clock.addDelta
  Clock.fromHourMin
  Clock.toString
module dependencies:
package dependencies: base-4.12.0.0* ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity base-4.12.0.0:Data.Monoid
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.Num 847723f2584d989dac1eada133ac3fb8
import  -/  base-4.12.0.0:GHC.Real f7dad82c1d43d80823865d3e6c6636e0
import  -/  base-4.12.0.0:GHC.Show 4e438f26d903388cc6c2c5d64ed01b98
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
a63101ac678dd25c6dee77cbe1ae83b5
  $fEqClock :: GHC.Classes.Eq Clock.Clock
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Clock.Clock Clock.$fEqClock_$c== Clock.$fEqClock_$c/= -}
a63101ac678dd25c6dee77cbe1ae83b5
  $fEqClock_$c/= :: Clock.Clock -> Clock.Clock -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Clock.Clock) (y :: Clock.Clock) ->
                 case x of wild { Clock.Clock h1 m1 ->
                 case y of wild1 { Clock.Clock h2 m2 ->
                 case GHC.Classes.eqInt h1 h2 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.eqInt m1 m2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
a63101ac678dd25c6dee77cbe1ae83b5
  $fEqClock_$c== :: Clock.Clock -> Clock.Clock -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Clock.Clock) (w1 :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Clock.Clock ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Clock.$w$c== ww4 ww2 ww9 ww7 } } } }) -}
970f6bc40e24f09169101d2f0842ba8b
  $tc'Clock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   526028766636847705##
                   10254689377622637213##
                   Clock.$trModule
                   Clock.$tc'Clock2
                   0#
                   Clock.$tc'Clock1) -}
85b06b8c33be38c23898d08232e1d37b
  $tc'Clock1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
078bd2e5325212b69c74b383294937d8
  $tc'Clock2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Clock.$tc'Clock3) -}
e305a3a7318c10b66d8e1d3ef1e4b0e1
  $tc'Clock3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Clock"#) -}
76d79694c477d6f4934d85762712b263
  $tcClock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12367134212650350641##
                   13625267764930306230##
                   Clock.$trModule
                   Clock.$trModule1
                   0#
                   GHC.Types.krep$*) -}
d37692c6d4ca9d239674f7c7caf76ab9
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Clock.$trModule3 Clock.$trModule1) -}
9bdf2dc344106f9646a2684b7e706a10
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Clock.$trModule2) -}
8b05df7bb63c9fe19ecf17ae52d38665
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Clock"#) -}
174e34d6f5f4cea6dc0b05a9f6afcade
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Clock.$trModule4) -}
7ad9672507d3d3fd89144dba3982b6fd
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("exercism-clock-2.3.0.8-KPE91lmxtbmH6ajC9xI2mZ"#) -}
60570ad25e9515c8d1eb39753df37289
  $w$c== ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.==# ww ww2 of lwild {
                   DEFAULT -> GHC.Types.False 1# -> GHC.Classes.eqInt ww1 ww3 }) -}
80833fa21b69f5750d1a80675c12bb70
  $wadjust :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2] -}
d52a79f3123153598c98c824e2458728
  $wfromHourMin ::
    GHC.Types.Int
    -> GHC.Types.Int -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 2, Strictness: <L,1*U(U)><L,U(U)>, Inline: [2],
     Unfolding: (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 (# case w of wild { GHC.Types.I# x ->
                    case w1 of ww { GHC.Types.I# ww1 ->
                    case GHC.Classes.divInt# ww1 60# of ww4 { DEFAULT ->
                    case Clock.$wadjust 24# (GHC.Prim.+# x ww4) of ww2 { DEFAULT ->
                    GHC.Types.I# ww2 } } } },
                    case w1 of ww { GHC.Types.I# ww1 ->
                    case Clock.$wadjust 60# ww1 of ww2 { DEFAULT ->
                    GHC.Types.I# ww2 } } #)) -}
16dc40e77bb07213a5477761349e9f6d
  $wtoString :: GHC.Prim.Int# -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, Strictness: <S,U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Types.Int) ->
                 let {
                   arg :: [GHC.Types.Char]
                   = case GHC.Show.$wshowSignedInt
                            0#
                            ww
                            (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackAppendCString#
                          Clock.toString3
                          (case ww1 of wild { GHC.Types.I# x ->
                           case GHC.Prim.<# x 10# of lwild {
                             DEFAULT
                             -> case GHC.Show.$wshowSignedInt
                                       0#
                                       x
                                       (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww7 ->
                                GHC.Types.: @ GHC.Types.Char ww3 ww7 }
                             1#
                             -> GHC.Base.++
                                  @ GHC.Types.Char
                                  Clock.toString1
                                  (case GHC.Show.$wshowSignedInt
                                          0#
                                          x
                                          (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww7 ->
                                   GHC.Types.: @ GHC.Types.Char ww3 ww7 }) } }))
                       ww5
                       ww6 }
                 } in
                 case GHC.Prim.<# ww 10# of lwild {
                   DEFAULT -> arg
                   1# -> GHC.Base.++ @ GHC.Types.Char Clock.toString1 arg }) -}
a63101ac678dd25c6dee77cbe1ae83b5
  data Clock = Clock GHC.Types.Int GHC.Types.Int
b56f3f991f83edb3b2050bc9cee743bf
  addDelta ::
    GHC.Types.Int -> GHC.Types.Int -> Clock.Clock -> Clock.Clock
  {- Arity: 3,
     Strictness: <L,1*U(U)><L,1*U(U)><S,1*U(1*U(U),1*U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Clock.Clock) ->
                 case w2 of ww { Clock.Clock ww1 ww2 ->
                 case Clock.$wfromHourMin
                        (case ww1 of wild { GHC.Types.I# x ->
                         case w of wild1 { GHC.Types.I# y ->
                         GHC.Types.I# (GHC.Prim.+# x y) } })
                        (case ww2 of wild { GHC.Types.I# x ->
                         case w1 of wild1 { GHC.Types.I# y ->
                         GHC.Types.I# (GHC.Prim.+# x y) } }) of ww3 { (#,#) ww4 ww5 ->
                 Clock.Clock ww4 ww5 } }) -}
c0d3dfcd8e939db9c63683409ee48d52
  fromHourMin :: GHC.Types.Int -> GHC.Types.Int -> Clock.Clock
  {- Arity: 2, Strictness: <L,1*U(U)><L,U(U)>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 case Clock.$wfromHourMin w w1 of ww { (#,#) ww1 ww2 ->
                 Clock.Clock ww1 ww2 }) -}
d3b41219f343a5f14bd558d817c2516f
  toString :: Clock.Clock -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 Clock.$wtoString ww4 ww2 } }) -}
02ac8d677daccbf76024f06b2ef2c8c4
  toString1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Clock.toString2) -}
48db56f1c06f92402700669a45a17922
  toString2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("0"#) -}
329703f17c0b352793ab949b1959ce3e
  toString3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":"#) -}
instance [safe] GHC.Classes.Eq [Clock.Clock] = Clock.$fEqClock
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

